/*
 * Cobo Wallet as a Service 2.0
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: support@cobo.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.cobo.waas2.model;

import java.util.Objects;
import com.cobo.waas2.model.TransactionBlockInfo;
import com.cobo.waas2.model.TransactionDestination;
import com.cobo.waas2.model.TransactionFee;
import com.cobo.waas2.model.TransactionInitiatorType;
import com.cobo.waas2.model.TransactionRawTxInfo;
import com.cobo.waas2.model.TransactionReplacement;
import com.cobo.waas2.model.TransactionResult;
import com.cobo.waas2.model.TransactionSource;
import com.cobo.waas2.model.TransactionStatus;
import com.cobo.waas2.model.TransactionSubStatus;
import com.cobo.waas2.model.TransactionType;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.cobo.waas2.JSON;

/**
 * TransactionWebhookEventData
 */
@javax.annotation.Generated(
    value = "org.openapitools.codegen.languages.JavaClientCodegen", 
    comments = "Generator version: 7.6.0"
)
public class TransactionWebhookEventData {
  /**
   * The data type of the event. When &#x60;data_type&#x60; is &#x60;Transaction&#x60;, it means the event uses the &#x60;transaction&#x60; schema as its data type.
   */
  @JsonAdapter(DataTypeEnum.Adapter.class)
  public enum DataTypeEnum {
    TRANSACTION("Transaction");

    private String value;

    DataTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DataTypeEnum fromValue(String value) {
      for (DataTypeEnum b : DataTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DataTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DataTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DataTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DataTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DataTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATA_TYPE = "data_type";
  @SerializedName(SERIALIZED_NAME_DATA_TYPE)
  private DataTypeEnum dataType;

  public static final String SERIALIZED_NAME_TRANSACTION_ID = "transaction_id";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_ID)
  private UUID transactionId;

  public static final String SERIALIZED_NAME_COBO_ID = "cobo_id";
  @SerializedName(SERIALIZED_NAME_COBO_ID)
  private String coboId;

  public static final String SERIALIZED_NAME_REQUEST_ID = "request_id";
  @SerializedName(SERIALIZED_NAME_REQUEST_ID)
  private String requestId;

  public static final String SERIALIZED_NAME_WALLET_ID = "wallet_id";
  @SerializedName(SERIALIZED_NAME_WALLET_ID)
  private String walletId;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TransactionType type;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private TransactionStatus status;

  public static final String SERIALIZED_NAME_SUB_STATUS = "sub_status";
  @SerializedName(SERIALIZED_NAME_SUB_STATUS)
  private TransactionSubStatus subStatus;

  public static final String SERIALIZED_NAME_FAILED_REASON = "failed_reason";
  @SerializedName(SERIALIZED_NAME_FAILED_REASON)
  private String failedReason;

  public static final String SERIALIZED_NAME_CHAIN_ID = "chain_id";
  @SerializedName(SERIALIZED_NAME_CHAIN_ID)
  private String chainId;

  public static final String SERIALIZED_NAME_TOKEN_ID = "token_id";
  @SerializedName(SERIALIZED_NAME_TOKEN_ID)
  private String tokenId;

  public static final String SERIALIZED_NAME_ASSET_ID = "asset_id";
  @SerializedName(SERIALIZED_NAME_ASSET_ID)
  private String assetId;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private TransactionSource source;

  public static final String SERIALIZED_NAME_DESTINATION = "destination";
  @SerializedName(SERIALIZED_NAME_DESTINATION)
  private TransactionDestination destination;

  public static final String SERIALIZED_NAME_RESULT = "result";
  @SerializedName(SERIALIZED_NAME_RESULT)
  private TransactionResult result;

  public static final String SERIALIZED_NAME_FEE = "fee";
  @SerializedName(SERIALIZED_NAME_FEE)
  private TransactionFee fee;

  public static final String SERIALIZED_NAME_INITIATOR = "initiator";
  @SerializedName(SERIALIZED_NAME_INITIATOR)
  private String initiator;

  public static final String SERIALIZED_NAME_INITIATOR_TYPE = "initiator_type";
  @SerializedName(SERIALIZED_NAME_INITIATOR_TYPE)
  private TransactionInitiatorType initiatorType;

  public static final String SERIALIZED_NAME_CONFIRMED_NUM = "confirmed_num";
  @SerializedName(SERIALIZED_NAME_CONFIRMED_NUM)
  private Integer confirmedNum;

  public static final String SERIALIZED_NAME_CONFIRMING_THRESHOLD = "confirming_threshold";
  @SerializedName(SERIALIZED_NAME_CONFIRMING_THRESHOLD)
  private Integer confirmingThreshold;

  public static final String SERIALIZED_NAME_TRANSACTION_HASH = "transaction_hash";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_HASH)
  private String transactionHash;

  public static final String SERIALIZED_NAME_BLOCK_INFO = "block_info";
  @SerializedName(SERIALIZED_NAME_BLOCK_INFO)
  private TransactionBlockInfo blockInfo;

  public static final String SERIALIZED_NAME_RAW_TX_INFO = "raw_tx_info";
  @SerializedName(SERIALIZED_NAME_RAW_TX_INFO)
  private TransactionRawTxInfo rawTxInfo;

  public static final String SERIALIZED_NAME_REPLACEMENT = "replacement";
  @SerializedName(SERIALIZED_NAME_REPLACEMENT)
  private TransactionReplacement replacement;

  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  private List<String> category = new ArrayList<>();

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_IS_LOOP = "is_loop";
  @SerializedName(SERIALIZED_NAME_IS_LOOP)
  private Boolean isLoop;

  public static final String SERIALIZED_NAME_CREATED_TIMESTAMP = "created_timestamp";
  @SerializedName(SERIALIZED_NAME_CREATED_TIMESTAMP)
  private Long createdTimestamp;

  public static final String SERIALIZED_NAME_UPDATED_TIMESTAMP = "updated_timestamp";
  @SerializedName(SERIALIZED_NAME_UPDATED_TIMESTAMP)
  private Long updatedTimestamp;

  public TransactionWebhookEventData() {
  }

  public TransactionWebhookEventData dataType(DataTypeEnum dataType) {
    this.dataType = dataType;
    return this;
  }

   /**
   * The data type of the event. When &#x60;data_type&#x60; is &#x60;Transaction&#x60;, it means the event uses the &#x60;transaction&#x60; schema as its data type.
   * @return dataType
  **/
  @javax.annotation.Nonnull
  public DataTypeEnum getDataType() {
    return dataType;
  }

  public void setDataType(DataTypeEnum dataType) {
    this.dataType = dataType;
  }


  public TransactionWebhookEventData transactionId(UUID transactionId) {
    this.transactionId = transactionId;
    return this;
  }

   /**
   * The transaction ID.
   * @return transactionId
  **/
  @javax.annotation.Nonnull
  public UUID getTransactionId() {
    return transactionId;
  }

  public void setTransactionId(UUID transactionId) {
    this.transactionId = transactionId;
  }


  public TransactionWebhookEventData coboId(String coboId) {
    this.coboId = coboId;
    return this;
  }

   /**
   * The Cobo ID, which can be used to track a transaction.
   * @return coboId
  **/
  @javax.annotation.Nullable
  public String getCoboId() {
    return coboId;
  }

  public void setCoboId(String coboId) {
    this.coboId = coboId;
  }


  public TransactionWebhookEventData requestId(String requestId) {
    this.requestId = requestId;
    return this;
  }

   /**
   * The request ID that is used to track a transaction request. The request ID is provided by you and must be unique within your organization.
   * @return requestId
  **/
  @javax.annotation.Nullable
  public String getRequestId() {
    return requestId;
  }

  public void setRequestId(String requestId) {
    this.requestId = requestId;
  }


  public TransactionWebhookEventData walletId(String walletId) {
    this.walletId = walletId;
    return this;
  }

   /**
   * For deposit transactions, this property represents the wallet ID of the transaction destination. For transactions of other types, this property represents the wallet ID of the transaction source.
   * @return walletId
  **/
  @javax.annotation.Nonnull
  public String getWalletId() {
    return walletId;
  }

  public void setWalletId(String walletId) {
    this.walletId = walletId;
  }


  public TransactionWebhookEventData type(TransactionType type) {
    this.type = type;
    return this;
  }

   /**
   * Get type
   * @return type
  **/
  @javax.annotation.Nullable
  public TransactionType getType() {
    return type;
  }

  public void setType(TransactionType type) {
    this.type = type;
  }


  public TransactionWebhookEventData status(TransactionStatus status) {
    this.status = status;
    return this;
  }

   /**
   * Get status
   * @return status
  **/
  @javax.annotation.Nonnull
  public TransactionStatus getStatus() {
    return status;
  }

  public void setStatus(TransactionStatus status) {
    this.status = status;
  }


  public TransactionWebhookEventData subStatus(TransactionSubStatus subStatus) {
    this.subStatus = subStatus;
    return this;
  }

   /**
   * Get subStatus
   * @return subStatus
  **/
  @javax.annotation.Nullable
  public TransactionSubStatus getSubStatus() {
    return subStatus;
  }

  public void setSubStatus(TransactionSubStatus subStatus) {
    this.subStatus = subStatus;
  }


  public TransactionWebhookEventData failedReason(String failedReason) {
    this.failedReason = failedReason;
    return this;
  }

   /**
   * (This property is applicable to approval failures and signature failures only) The reason why the transaction failed.
   * @return failedReason
  **/
  @javax.annotation.Nullable
  public String getFailedReason() {
    return failedReason;
  }

  public void setFailedReason(String failedReason) {
    this.failedReason = failedReason;
  }


  public TransactionWebhookEventData chainId(String chainId) {
    this.chainId = chainId;
    return this;
  }

   /**
   * The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](/v2/api-references/wallets/list-enabled-chains).
   * @return chainId
  **/
  @javax.annotation.Nullable
  public String getChainId() {
    return chainId;
  }

  public void setChainId(String chainId) {
    this.chainId = chainId;
  }


  public TransactionWebhookEventData tokenId(String tokenId) {
    this.tokenId = tokenId;
    return this;
  }

   /**
   * The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](/v2/api-references/wallets/list-enabled-tokens).
   * @return tokenId
  **/
  @javax.annotation.Nullable
  public String getTokenId() {
    return tokenId;
  }

  public void setTokenId(String tokenId) {
    this.tokenId = tokenId;
  }


  public TransactionWebhookEventData assetId(String assetId) {
    this.assetId = assetId;
    return this;
  }

   /**
   * (This concept applies to Exchange Wallets only) The asset ID. An asset ID is the unique identifier of the asset held within your linked exchange account.
   * @return assetId
  **/
  @javax.annotation.Nullable
  public String getAssetId() {
    return assetId;
  }

  public void setAssetId(String assetId) {
    this.assetId = assetId;
  }


  public TransactionWebhookEventData source(TransactionSource source) {
    this.source = source;
    return this;
  }

   /**
   * Get source
   * @return source
  **/
  @javax.annotation.Nonnull
  public TransactionSource getSource() {
    return source;
  }

  public void setSource(TransactionSource source) {
    this.source = source;
  }


  public TransactionWebhookEventData destination(TransactionDestination destination) {
    this.destination = destination;
    return this;
  }

   /**
   * Get destination
   * @return destination
  **/
  @javax.annotation.Nonnull
  public TransactionDestination getDestination() {
    return destination;
  }

  public void setDestination(TransactionDestination destination) {
    this.destination = destination;
  }


  public TransactionWebhookEventData result(TransactionResult result) {
    this.result = result;
    return this;
  }

   /**
   * Get result
   * @return result
  **/
  @javax.annotation.Nullable
  public TransactionResult getResult() {
    return result;
  }

  public void setResult(TransactionResult result) {
    this.result = result;
  }


  public TransactionWebhookEventData fee(TransactionFee fee) {
    this.fee = fee;
    return this;
  }

   /**
   * Get fee
   * @return fee
  **/
  @javax.annotation.Nullable
  public TransactionFee getFee() {
    return fee;
  }

  public void setFee(TransactionFee fee) {
    this.fee = fee;
  }


  public TransactionWebhookEventData initiator(String initiator) {
    this.initiator = initiator;
    return this;
  }

   /**
   * The transaction initiator.
   * @return initiator
  **/
  @javax.annotation.Nullable
  public String getInitiator() {
    return initiator;
  }

  public void setInitiator(String initiator) {
    this.initiator = initiator;
  }


  public TransactionWebhookEventData initiatorType(TransactionInitiatorType initiatorType) {
    this.initiatorType = initiatorType;
    return this;
  }

   /**
   * Get initiatorType
   * @return initiatorType
  **/
  @javax.annotation.Nonnull
  public TransactionInitiatorType getInitiatorType() {
    return initiatorType;
  }

  public void setInitiatorType(TransactionInitiatorType initiatorType) {
    this.initiatorType = initiatorType;
  }


  public TransactionWebhookEventData confirmedNum(Integer confirmedNum) {
    this.confirmedNum = confirmedNum;
    return this;
  }

   /**
   * The number of confirmations this transaction has received.
   * @return confirmedNum
  **/
  @javax.annotation.Nullable
  public Integer getConfirmedNum() {
    return confirmedNum;
  }

  public void setConfirmedNum(Integer confirmedNum) {
    this.confirmedNum = confirmedNum;
  }


  public TransactionWebhookEventData confirmingThreshold(Integer confirmingThreshold) {
    this.confirmingThreshold = confirmingThreshold;
    return this;
  }

   /**
   * The minimum number of confirmations required to deem a transaction secure. The common threshold is 6 for a Bitcoin transaction.
   * @return confirmingThreshold
  **/
  @javax.annotation.Nullable
  public Integer getConfirmingThreshold() {
    return confirmingThreshold;
  }

  public void setConfirmingThreshold(Integer confirmingThreshold) {
    this.confirmingThreshold = confirmingThreshold;
  }


  public TransactionWebhookEventData transactionHash(String transactionHash) {
    this.transactionHash = transactionHash;
    return this;
  }

   /**
   * The transaction hash.
   * @return transactionHash
  **/
  @javax.annotation.Nullable
  public String getTransactionHash() {
    return transactionHash;
  }

  public void setTransactionHash(String transactionHash) {
    this.transactionHash = transactionHash;
  }


  public TransactionWebhookEventData blockInfo(TransactionBlockInfo blockInfo) {
    this.blockInfo = blockInfo;
    return this;
  }

   /**
   * Get blockInfo
   * @return blockInfo
  **/
  @javax.annotation.Nullable
  public TransactionBlockInfo getBlockInfo() {
    return blockInfo;
  }

  public void setBlockInfo(TransactionBlockInfo blockInfo) {
    this.blockInfo = blockInfo;
  }


  public TransactionWebhookEventData rawTxInfo(TransactionRawTxInfo rawTxInfo) {
    this.rawTxInfo = rawTxInfo;
    return this;
  }

   /**
   * Get rawTxInfo
   * @return rawTxInfo
  **/
  @javax.annotation.Nullable
  public TransactionRawTxInfo getRawTxInfo() {
    return rawTxInfo;
  }

  public void setRawTxInfo(TransactionRawTxInfo rawTxInfo) {
    this.rawTxInfo = rawTxInfo;
  }


  public TransactionWebhookEventData replacement(TransactionReplacement replacement) {
    this.replacement = replacement;
    return this;
  }

   /**
   * Get replacement
   * @return replacement
  **/
  @javax.annotation.Nullable
  public TransactionReplacement getReplacement() {
    return replacement;
  }

  public void setReplacement(TransactionReplacement replacement) {
    this.replacement = replacement;
  }


  public TransactionWebhookEventData category(List<String> category) {
    this.category = category;
    return this;
  }

  public TransactionWebhookEventData addCategoryItem(String categoryItem) {
    if (this.category == null) {
      this.category = new ArrayList<>();
    }
    this.category.add(categoryItem);
    return this;
  }

   /**
   * A custom transaction category for you to identify your transfers more easily.
   * @return category
  **/
  @javax.annotation.Nullable
  public List<String> getCategory() {
    return category;
  }

  public void setCategory(List<String> category) {
    this.category = category;
  }


  public TransactionWebhookEventData description(String description) {
    this.description = description;
    return this;
  }

   /**
   * The description for your transaction.
   * @return description
  **/
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public TransactionWebhookEventData isLoop(Boolean isLoop) {
    this.isLoop = isLoop;
    return this;
  }

   /**
   * Whether the transaction is a Loop transfer. For more information about Loop, see [Loop&#39;s website](https://loop.top/).  - &#x60;true&#x60;: The transaction is a Loop transfer. - &#x60;false&#x60;: The transaction is not a Loop transfer. 
   * @return isLoop
  **/
  @javax.annotation.Nullable
  public Boolean getIsLoop() {
    return isLoop;
  }

  public void setIsLoop(Boolean isLoop) {
    this.isLoop = isLoop;
  }


  public TransactionWebhookEventData createdTimestamp(Long createdTimestamp) {
    this.createdTimestamp = createdTimestamp;
    return this;
  }

   /**
   * The time when the transaction was created, in Unix timestamp format, measured in milliseconds.
   * @return createdTimestamp
  **/
  @javax.annotation.Nullable
  public Long getCreatedTimestamp() {
    return createdTimestamp;
  }

  public void setCreatedTimestamp(Long createdTimestamp) {
    this.createdTimestamp = createdTimestamp;
  }


  public TransactionWebhookEventData updatedTimestamp(Long updatedTimestamp) {
    this.updatedTimestamp = updatedTimestamp;
    return this;
  }

   /**
   * The time when the transaction was updated, in Unix timestamp format, measured in milliseconds.
   * @return updatedTimestamp
  **/
  @javax.annotation.Nullable
  public Long getUpdatedTimestamp() {
    return updatedTimestamp;
  }

  public void setUpdatedTimestamp(Long updatedTimestamp) {
    this.updatedTimestamp = updatedTimestamp;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the TransactionWebhookEventData instance itself
   */
  public TransactionWebhookEventData putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TransactionWebhookEventData transactionWebhookEventData = (TransactionWebhookEventData) o;
    return Objects.equals(this.dataType, transactionWebhookEventData.dataType) &&
        Objects.equals(this.transactionId, transactionWebhookEventData.transactionId) &&
        Objects.equals(this.coboId, transactionWebhookEventData.coboId) &&
        Objects.equals(this.requestId, transactionWebhookEventData.requestId) &&
        Objects.equals(this.walletId, transactionWebhookEventData.walletId) &&
        Objects.equals(this.type, transactionWebhookEventData.type) &&
        Objects.equals(this.status, transactionWebhookEventData.status) &&
        Objects.equals(this.subStatus, transactionWebhookEventData.subStatus) &&
        Objects.equals(this.failedReason, transactionWebhookEventData.failedReason) &&
        Objects.equals(this.chainId, transactionWebhookEventData.chainId) &&
        Objects.equals(this.tokenId, transactionWebhookEventData.tokenId) &&
        Objects.equals(this.assetId, transactionWebhookEventData.assetId) &&
        Objects.equals(this.source, transactionWebhookEventData.source) &&
        Objects.equals(this.destination, transactionWebhookEventData.destination) &&
        Objects.equals(this.result, transactionWebhookEventData.result) &&
        Objects.equals(this.fee, transactionWebhookEventData.fee) &&
        Objects.equals(this.initiator, transactionWebhookEventData.initiator) &&
        Objects.equals(this.initiatorType, transactionWebhookEventData.initiatorType) &&
        Objects.equals(this.confirmedNum, transactionWebhookEventData.confirmedNum) &&
        Objects.equals(this.confirmingThreshold, transactionWebhookEventData.confirmingThreshold) &&
        Objects.equals(this.transactionHash, transactionWebhookEventData.transactionHash) &&
        Objects.equals(this.blockInfo, transactionWebhookEventData.blockInfo) &&
        Objects.equals(this.rawTxInfo, transactionWebhookEventData.rawTxInfo) &&
        Objects.equals(this.replacement, transactionWebhookEventData.replacement) &&
        Objects.equals(this.category, transactionWebhookEventData.category) &&
        Objects.equals(this.description, transactionWebhookEventData.description) &&
        Objects.equals(this.isLoop, transactionWebhookEventData.isLoop) &&
        Objects.equals(this.createdTimestamp, transactionWebhookEventData.createdTimestamp) &&
        Objects.equals(this.updatedTimestamp, transactionWebhookEventData.updatedTimestamp)&&
        Objects.equals(this.additionalProperties, transactionWebhookEventData.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dataType, transactionId, coboId, requestId, walletId, type, status, subStatus, failedReason, chainId, tokenId, assetId, source, destination, result, fee, initiator, initiatorType, confirmedNum, confirmingThreshold, transactionHash, blockInfo, rawTxInfo, replacement, category, description, isLoop, createdTimestamp, updatedTimestamp, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TransactionWebhookEventData {\n");
    sb.append("    dataType: ").append(toIndentedString(dataType)).append("\n");
    sb.append("    transactionId: ").append(toIndentedString(transactionId)).append("\n");
    sb.append("    coboId: ").append(toIndentedString(coboId)).append("\n");
    sb.append("    requestId: ").append(toIndentedString(requestId)).append("\n");
    sb.append("    walletId: ").append(toIndentedString(walletId)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    subStatus: ").append(toIndentedString(subStatus)).append("\n");
    sb.append("    failedReason: ").append(toIndentedString(failedReason)).append("\n");
    sb.append("    chainId: ").append(toIndentedString(chainId)).append("\n");
    sb.append("    tokenId: ").append(toIndentedString(tokenId)).append("\n");
    sb.append("    assetId: ").append(toIndentedString(assetId)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    destination: ").append(toIndentedString(destination)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("    fee: ").append(toIndentedString(fee)).append("\n");
    sb.append("    initiator: ").append(toIndentedString(initiator)).append("\n");
    sb.append("    initiatorType: ").append(toIndentedString(initiatorType)).append("\n");
    sb.append("    confirmedNum: ").append(toIndentedString(confirmedNum)).append("\n");
    sb.append("    confirmingThreshold: ").append(toIndentedString(confirmingThreshold)).append("\n");
    sb.append("    transactionHash: ").append(toIndentedString(transactionHash)).append("\n");
    sb.append("    blockInfo: ").append(toIndentedString(blockInfo)).append("\n");
    sb.append("    rawTxInfo: ").append(toIndentedString(rawTxInfo)).append("\n");
    sb.append("    replacement: ").append(toIndentedString(replacement)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    isLoop: ").append(toIndentedString(isLoop)).append("\n");
    sb.append("    createdTimestamp: ").append(toIndentedString(createdTimestamp)).append("\n");
    sb.append("    updatedTimestamp: ").append(toIndentedString(updatedTimestamp)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("data_type");
    openapiFields.add("transaction_id");
    openapiFields.add("cobo_id");
    openapiFields.add("request_id");
    openapiFields.add("wallet_id");
    openapiFields.add("type");
    openapiFields.add("status");
    openapiFields.add("sub_status");
    openapiFields.add("failed_reason");
    openapiFields.add("chain_id");
    openapiFields.add("token_id");
    openapiFields.add("asset_id");
    openapiFields.add("source");
    openapiFields.add("destination");
    openapiFields.add("result");
    openapiFields.add("fee");
    openapiFields.add("initiator");
    openapiFields.add("initiator_type");
    openapiFields.add("confirmed_num");
    openapiFields.add("confirming_threshold");
    openapiFields.add("transaction_hash");
    openapiFields.add("block_info");
    openapiFields.add("raw_tx_info");
    openapiFields.add("replacement");
    openapiFields.add("category");
    openapiFields.add("description");
    openapiFields.add("is_loop");
    openapiFields.add("created_timestamp");
    openapiFields.add("updated_timestamp");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("data_type");
    openapiRequiredFields.add("transaction_id");
    openapiRequiredFields.add("wallet_id");
    openapiRequiredFields.add("status");
    openapiRequiredFields.add("source");
    openapiRequiredFields.add("destination");
    openapiRequiredFields.add("initiator_type");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to TransactionWebhookEventData
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TransactionWebhookEventData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TransactionWebhookEventData is not found in the empty JSON string", TransactionWebhookEventData.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TransactionWebhookEventData.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("data_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `data_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("data_type").toString()));
      }
      // validate the required field `data_type`
      DataTypeEnum.validateJsonElement(jsonObj.get("data_type"));
      if (!jsonObj.get("transaction_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transaction_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transaction_id").toString()));
      }
      if ((jsonObj.get("cobo_id") != null && !jsonObj.get("cobo_id").isJsonNull()) && !jsonObj.get("cobo_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cobo_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cobo_id").toString()));
      }
      if ((jsonObj.get("request_id") != null && !jsonObj.get("request_id").isJsonNull()) && !jsonObj.get("request_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `request_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("request_id").toString()));
      }
      if (!jsonObj.get("wallet_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `wallet_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("wallet_id").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TransactionType.validateJsonElement(jsonObj.get("type"));
      }
      // validate the required field `status`
      TransactionStatus.validateJsonElement(jsonObj.get("status"));
      // validate the optional field `sub_status`
      if (jsonObj.get("sub_status") != null && !jsonObj.get("sub_status").isJsonNull()) {
        TransactionSubStatus.validateJsonElement(jsonObj.get("sub_status"));
      }
      if ((jsonObj.get("failed_reason") != null && !jsonObj.get("failed_reason").isJsonNull()) && !jsonObj.get("failed_reason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `failed_reason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("failed_reason").toString()));
      }
      if ((jsonObj.get("chain_id") != null && !jsonObj.get("chain_id").isJsonNull()) && !jsonObj.get("chain_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `chain_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("chain_id").toString()));
      }
      if ((jsonObj.get("token_id") != null && !jsonObj.get("token_id").isJsonNull()) && !jsonObj.get("token_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `token_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("token_id").toString()));
      }
      if ((jsonObj.get("asset_id") != null && !jsonObj.get("asset_id").isJsonNull()) && !jsonObj.get("asset_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `asset_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("asset_id").toString()));
      }
      // validate the required field `source`
      TransactionSource.validateJsonElement(jsonObj.get("source"));
      // validate the required field `destination`
      TransactionDestination.validateJsonElement(jsonObj.get("destination"));
      // validate the optional field `result`
      if (jsonObj.get("result") != null && !jsonObj.get("result").isJsonNull()) {
        TransactionResult.validateJsonElement(jsonObj.get("result"));
      }
      // validate the optional field `fee`
      if (jsonObj.get("fee") != null && !jsonObj.get("fee").isJsonNull()) {
        TransactionFee.validateJsonElement(jsonObj.get("fee"));
      }
      if ((jsonObj.get("initiator") != null && !jsonObj.get("initiator").isJsonNull()) && !jsonObj.get("initiator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `initiator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("initiator").toString()));
      }
      // validate the required field `initiator_type`
      TransactionInitiatorType.validateJsonElement(jsonObj.get("initiator_type"));
      if ((jsonObj.get("transaction_hash") != null && !jsonObj.get("transaction_hash").isJsonNull()) && !jsonObj.get("transaction_hash").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transaction_hash` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transaction_hash").toString()));
      }
      // validate the optional field `block_info`
      if (jsonObj.get("block_info") != null && !jsonObj.get("block_info").isJsonNull()) {
        TransactionBlockInfo.validateJsonElement(jsonObj.get("block_info"));
      }
      // validate the optional field `raw_tx_info`
      if (jsonObj.get("raw_tx_info") != null && !jsonObj.get("raw_tx_info").isJsonNull()) {
        TransactionRawTxInfo.validateJsonElement(jsonObj.get("raw_tx_info"));
      }
      // validate the optional field `replacement`
      if (jsonObj.get("replacement") != null && !jsonObj.get("replacement").isJsonNull()) {
        TransactionReplacement.validateJsonElement(jsonObj.get("replacement"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("category") != null && !jsonObj.get("category").isJsonNull() && !jsonObj.get("category").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `category` to be an array in the JSON string but got `%s`", jsonObj.get("category").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TransactionWebhookEventData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TransactionWebhookEventData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TransactionWebhookEventData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TransactionWebhookEventData.class));

       return (TypeAdapter<T>) new TypeAdapter<TransactionWebhookEventData>() {
           @Override
           public void write(JsonWriter out, TransactionWebhookEventData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   JsonElement jsonElement = gson.toJsonTree(entry.getValue());
                   if (jsonElement.isJsonArray()) {
                     obj.add(entry.getKey(), jsonElement.getAsJsonArray());
                   } else {
                     obj.add(entry.getKey(), jsonElement.getAsJsonObject());
                   }
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public TransactionWebhookEventData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             TransactionWebhookEventData instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TransactionWebhookEventData given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TransactionWebhookEventData
  * @throws IOException if the JSON string is invalid with respect to TransactionWebhookEventData
  */
  public static TransactionWebhookEventData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TransactionWebhookEventData.class);
  }

 /**
  * Convert an instance of TransactionWebhookEventData to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

